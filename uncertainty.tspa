loadscript Uncertainty
-- $Title: Uncertainty
-- $Product: DAQ6510, DMM6500
-- $Tag: Measurement uncertainty, Tolerance, Error margin
-- $Description: Calculates measurement uncertainty
-- $Requires: v1.0.01f
-- $Icon: uncertainty_icon
-- Last Updated: $Date: 2024-11-18
--[[
Script: Uncertainty.tspa
Written by: Johannes Raschke
Based on Brad Odhner's Probe_Hold.tspa (Keithley Applications Engineering)

For remote operation, the most interesting function is
getUncertainty(): it returns the measurement uncertainty of the last measured value
in defbuffer1, assumig it was taken with the current instrument stettings

TODO: 
* Hints in ACV mode trigger an error because there are no NPLC
* Stop passing calInterval as a paramter - it's global anyway...
* Disable / clear error limit display if Overflow
* Support ratio measurement functions of the 6500
* add support for K7510 (I probably won't have the nerve to do that)

***********************************************************
*** Copyright 2024 Johannes Raschke                     ***
*** All rights reserved.                                ***
*** This source code is licensed under the CC BY 4.0    ***
*** license.                                            ***
*** See https://creativecommons.org/licenses/by/4.0/    ***
*** Most important points: You are free to share and    ***
*** adapt this work, but you must give appropriate      ***
*** credit.                                             ***
***********************************************************
]]--

function createMainScreen() -- Create grid lines on the swipe screen
	-- Create grid line for each reading.
    local gridLines = {}
	
    -- Create swipe screen
    swipe_id = display.create(display.SCREEN_HOME, display.OBJ_SWIPE, 'Uncertainty')
    
    -- Column lines
	gridLines[1] = display.create(swipe_id, display.OBJ_LINE, 1, 5, 1, 200)
	gridLines[2] = display.create(swipe_id, display.OBJ_LINE, 270, 5, 270, 200)
    gridLines[3] = display.create(swipe_id, display.OBJ_LINE, 600, 5, 600, 200)
	-- Row lines
	gridLines[4] = display.create(swipe_id, display.OBJ_LINE, 1, 50, 600, 50)
	gridLines[5] = display.create(swipe_id, display.OBJ_LINE, 1, 100, 600, 100)
	gridLines[6] = display.create(swipe_id, display.OBJ_LINE, 1, 150, 600, 150)

	for i = 1, table.getn(gridLines) do
		display.setcolor(gridLines[i], 0x7f7f7f)
	end

    -- Now Create objects on the swipe screen that aren't the grid lines
    DisplayItems[1] = display.create(swipe_id, display.OBJ_TEXT, 12, 35, "Abs. uncertainty", UNCERTAINTY_COLOR_VALUE_LABEL, display.FONT_LARGE)
	DisplayItems[2] = display.create(swipe_id, display.OBJ_TEXT, 12, 85,   "Rel. uncertainty", UNCERTAINTY_COLOR_VALUE_LABEL, display.FONT_LARGE)
	DisplayItems[3] = display.create(swipe_id, display.OBJ_TEXT, 12, 135,  "Lower error limit", UNCERTAINTY_COLOR_VALUE_LABEL, display.FONT_LARGE)
	DisplayItems[4] = display.create(swipe_id, display.OBJ_TEXT, 12, 185,  "Upper error limit", UNCERTAINTY_COLOR_VALUE_LABEL, display.FONT_LARGE)

	DisplayItems[5] = display.create(swipe_id, display.OBJ_TEXT, 275, 35,  "---", UNCERTAINTY_COLOR_VALUE_VALUE, display.FONT_LARGE)
	DisplayItems[6] = display.create(swipe_id, display.OBJ_TEXT, 275, 85,  "---", UNCERTAINTY_COLOR_VALUE_VALUE, display.FONT_LARGE)
	DisplayItems[7] = display.create(swipe_id, display.OBJ_TEXT, 275, 135, "---", UNCERTAINTY_COLOR_VALUE_VALUE, display.FONT_LARGE)
	DisplayItems[8] = display.create(swipe_id, display.OBJ_TEXT, 275, 185, "---", UNCERTAINTY_COLOR_VALUE_VALUE, display.FONT_LARGE)

    -- Settings button
    local settings_button_id = display.create(swipe_id, display.OBJ_BUTTON, 630, 10, "Settings")
    display.setevent(settings_button_id, display.EVENT_PRESS, "open_settings()")

    -- Hints button
    local hints_button_id = display.create(swipe_id, display.OBJ_BUTTON, 630, 78, "Hints")
    display.setevent(hints_button_id, display.EVENT_PRESS, "show_hints()")

    -- About button
    local about_button_id = display.create(swipe_id, display.OBJ_BUTTON, 630, 144, "About")
    display.setevent(about_button_id, display.EVENT_PRESS, "show_about()")

    Screen_is_setup = 1 --if the script is restarted this will stop multiple swipe screens being created
end

function open_settings() -- Opens the settings screen
    Settings_id = display.create(display.ROOT, display.OBJ_SCREEN, 'Uncertainty Settings')

    local calibrationInterval_id = display.create(Settings_id, display.OBJ_EDIT_OPTION, 200, 10, "Cal. interval", "Calibration interval", "24 h", "90 days", "1 year", "2 years")
    display.setevent(calibrationInterval_id, display.EVENT_PRESS, "calIntervalSettingEvent(%value)")
    display.setvalue(calibrationInterval_id, CalibrationInterval)

    local triggerReadingsFromApp_id = display.create(Settings_id, display.OBJ_EDIT_OPTION, 200, 90, "AutoTrigger", "App triggers cont. readings", "On", "Off") -- 1=On, 2=Off
    display.setevent(triggerReadingsFromApp_id, display.EVENT_PRESS, "triggerReadingsFromAppEvent(%value)")
    display.setvalue(triggerReadingsFromApp_id, TriggerReadingsFromApp)

    local AcvFrequency_id = display.create(Settings_id, display.OBJ_EDIT_OPTION, 200, 170, "ACV frequency", "Frequency for ACV", "3 Hz - 5 Hz",   -- 1
                                                                                                                                "5 Hz - 10 Hz",   -- 2
                                                                                                                                "10 Hz - 20 kHz", -- 3
                                                                                                                                "20 - 50 kHz",    -- 4
                                                                                                                                "50 - 100 kHz",   -- 5
                                                                                                                                "100 - 300 kHz")  -- 6
    display.setevent(AcvFrequency_id, display.EVENT_PRESS, "AcvFrequencyEvent(%value)")
    display.setvalue(AcvFrequency_id, AcvFrequency)

    local AciFrequency_id = display.create(Settings_id, display.OBJ_EDIT_OPTION, 200, 250, "ACI frequency", "Frequency for ACI", "3 Hz - 5 Hz",     -- 1
                                                                                                                                 "5 Hz - 1 kHz",    -- 2
                                                                                                                                 "1 kHz - 5 kHz",   -- 3
                                                                                                                                 "5 kHz - 10 kHz")  -- 4                                                                                                                         
    display.setevent(AciFrequency_id, display.EVENT_PRESS, "AciFrequencyEvent(%value)")
    display.setvalue(AciFrequency_id, AciFrequency)

    -- note: add next button here

    local exit_id = display.create(Settings_id, display.OBJ_BUTTON, 350, 360, "Back")
    display.setevent(exit_id, display.EVENT_PRESS, "close_settings()")
end

function calIntervalSettingEvent(v) -- the selector passes 1 for 24h, 2 for 90 days, 3 for 1 year, 4 for 2 years
	CalibrationInterval = v
end

function triggerReadingsFromAppEvent(v)
    TriggerReadingsFromApp = v
end

function AcvFrequencyEvent(v)
    AcvFrequency = v
end

function AciFrequencyEvent(v)
    AciFrequency = v
end

function close_settings() -- Closes the settings screen and goes back to swipe_id
    display.changescreen(display.SCREEN_HOME)
    display.delete(Settings_id)
    delay() -- Needed to allow change to swipe_id?
    display.changescreen(swipe_id)
    collectgarbage()
end

function show_hints()
    Hints_id = display.create(display.ROOT, display.OBJ_SCREEN, 'Uncertainty improvement hints')
    local operatorHints = {} --create a new list
    

    if((dmm.measure.func == dmm.FUNC_RESISTANCE) or (dmm.measure.func == dmm.FUNC_4W_RESISTANCE)
        or (dmm.measure.func == dmm.FUNC_DC_CURRENT) or (dmm.measure.func == dmm.FUNC_DC_VOLTAGE)
        or (dmm.measure.func == dmm.FUNC_TEMPERATURE) or (dmm.measure.func == dmm.FUNC_DCV_RATIO)) then -- all non-AC measurements
        
        if(dmm.measure.nplc < 1.0) then
            table.insert(operatorHints, "- Use NPLC = 1 to 5 for best noise performance")
        elseif(math.mod(dmm.measure.nplc,1) ~= 0) then -- NPLC > 1, but non-integer
            table.insert(operatorHints, "- Set NPLC to a number without decimal places for better")
            table.insert(operatorHints, "   AC line interference rejection")
        end

        if(dmm.measure.linesync == dmm.OFF) then
            table.insert(operatorHints, "- Switch on Line Sync to reduce noise and improve")
            table.insert(operatorHints, "   NMRR and CMRR (even at high NPLC settings)")
        end
    end
    if((dmm.measure.func == dmm.FUNC_DC_VOLTAGE) and  (dmm.measure.range <= 10 ) and (dmm.measure.inputimpedance ~= dmm.IMPEDANCE_AUTO)) then
        table.insert(operatorHints, "- Set the input impedance to AUTO for lower noise and higher")
        table.insert(operatorHints, "   isolation under most circumstances (see ref manual)")
    end

    if((dmm.measure.func == dmm.FUNC_RESISTANCE) or (dmm.measure.func == dmm.FUNC_4W_RESISTANCE)
        or (dmm.measure.func == dmm.FUNC_DC_CURRENT) or (dmm.measure.func == dmm.FUNC_DC_VOLTAGE)
        or (dmm.measure.func == dmm.FUNC_TEMPERATURE) or (dmm.measure.func == dmm.FUNC_DCV_RATIO)) 
        or (dmm.measure.func == dmm.FUNC_DIODE)then
        if(dmm.measure.autozero.enable == dmm.OFF) then
            table.insert(operatorHints, "- Switch on Auto Zero to reduce offset drift")
        end
    end
    if((dmm.measure.func == dmm.FUNC_RESISTANCE) and (dmm.measure.range <= 1000 )) then
        table.insert(operatorHints, "- Consider using 4-wire resistance mode, especially")
        table.insert(operatorHints, "   when measuring below 1 kOhm")        
    end
    if((dmm.measure.func == dmm.FUNC_RESISTANCE) and (dmm.measure.range <= 100000) and (dmm.measure.rel.enable == dmm.OFF)) then
        table.insert(operatorHints, "- In 2-wire resistance mode, proper zeroing using")
        table.insert(operatorHints, "   the rel function is required for rated accuracy")
    end
    if((dmm.measure.func == dmm.FUNC_4W_RESISTANCE) and (dmm.measure.offsetcompensation.enable == dmm.OCOMP_OFF)) then
        table.insert(operatorHints, "- In 4-wire mode, Offset Compensation should be used")
        table.insert(operatorHints, "   (adds noise but is required for rated uncertainty)")
    end
    if((dmm.measure.func == dmm.FUNC_4W_RESISTANCE) and (dmm.measure.opendetector == dmm.ON) and (dmm.measure.range >= 10000)) then
        table.insert(operatorHints, "- Open Lead detection decreases accuracy, especially")
        table.insert(operatorHints, "   for 10 k to 1 M ranges")
    end
    if((dmm.measure.func == dmm.FUNC_4W_RESISTANCE) or (dmm.measure.func == dmm.FUNC_RESISTANCE)) then
        if((dmm.measure.range == 1) or (dmm.measure.range == 10)) then
            if(dmm.measure.filter.enable == dmm.OFF) then
                table.insert(operatorHints, "- 1 Ohm and 10 Ohm ranges require a 10-reading digital filter at")
                table.insert(operatorHints, "   1 PLC or 2-reading digital filter at 5 PLC")
            end
        elseif((dmm.measure.range == 10000000) or (dmm.measure.range == 100000000)) then -- 10 or 100 MOhm 
            if(dmm.measure.nplc < 1.0) then
                table.insert(operatorHints, "- Noise in 10 MOhm and 100 MOhm ranges is only defined for")
                table.insert(operatorHints, "   NPLC >= 1. These ranges are susceptible to AC interference!")
            end
        end  
    end

    if(dmm.measure.func == dmm.FUNC_DIODE) then
        table.insert(operatorHints, "- Make sure to select the suitable bias level for your DUT (10 uA - 10 mA)")
        table.insert(operatorHints, "- Specifications do not include errors from cable or connection resistance")
    end

    if(dmm.measure.func == dmm.FUNC_CAPACITANCE) then
        table.insert(operatorHints, "- Accuracies are specified for cable, channel, and other stray")
        table.insert(operatorHints, "   connector capacitance properly zeroed with the REL function.")
    end

    if(dmm.measure.func == dmm.FUNC_AC_VOLTAGE) or (dmm.measure.func == dmm.FUNC_AC_CURRENT) then   
        -- check for too high bandwidth (high-pass) settings 
        if(dmm.measure.detectorbandwidth == dmm.DETECTBW_30HZ) or (dmm.measure.detectorbandwidth == dmm.DETECTBW_300HZ) then
            if(AcvFrequency <= ACV_FREQUENCY_5HzTo10Hz) then 
                -- bandwidth (highh pass filter) is certainly set too high
                table.insert(operatorHints, "- Set the AC detector bandwidth to 3 Hz (lower than lowest signal frequency)!")
            elseif (dmm.measure.detectorbandwidth == dmm.DETECTBW_300HZ) then
                if(AcvFrequency == ACV_FREQUENCY_10HzTo20kHz) then 
                    -- bandwidth (highh pass filter) is possibly set too high
                    table.insert(operatorHints, "- If your signal frequency is <300 Hz, set the AC detector bandwidth")
                    table.insert(operatorHints, "   to 30 Hz or 3 Hz (lower than lowest signal frequency component)!")
                end
            end
            -- now check for unnecessary low bandwidth settings
        elseif (dmm.measure.detectorbandwidth == dmm.DETECTBW_3HZ) or (dmm.measure.detectorbandwidth == dmm.DETECTBW_300HZ) then
            if(AcvFrequency >= ACV_FREQUENCY_10HzTo20kHz) then -- bandwidth is set lower than necessary
                table.insert(operatorHints, "- Set the AC detector bandwidth to the highest value below the")
                table.insert(operatorHints, "    lowest frequency component of your signal!")
            end
        end
    end

    if (table.getn(operatorHints) == 0) then-- no hints available
    
        table.insert(operatorHints, "The instrument seems to be configured perfectly for best")
        table.insert(operatorHints, "measurement uncertainty!")
    end

    for key,value in next, operatorHints do
        display.create(Hints_id, display.OBJ_TEXT, 12, 32*key, value, UNCERTAINTY_COLOR_HINTS_TEXT, display.FONT_MEDIUM)
    end
    
    local exit_id = display.create(Hints_id, display.OBJ_BUTTON, 350, 360, "Back")
    display.setevent(exit_id, display.EVENT_PRESS, "close_hints()")
end

function close_hints() -- Closes the hints screen and goes back to swipe_id
    display.changescreen(display.SCREEN_HOME)
    display.delete(Hints_id)
    delay() -- Needed to allow change to swipe_id?
    display.changescreen(swipe_id)
    -- operatorHints = {} have become local...
    collectgarbage()
end

function show_about() -- Opens the about screen
    about_id = display.create(display.ROOT, display.OBJ_SCREEN, 'About Uncertainty Calculator...')
    local textLines = {} --create a new list
    
    table.insert(textLines, "An app for the Keithley 6500, written by Johannes Raschke,")
    table.insert(textLines, "using information from Keithley SPEC-DMM6500 Rev. A / April 2018")
    table.insert(textLines, "Based on Brad Odhner's Probe_Hold.tspa")
    table.insert(textLines, "For remote operation, the most interesting function is")
    table.insert(textLines, "getUncertainty(): it returns the measurement uncertainty")
    table.insert(textLines, "of the last measured value in defbuffer1, assumig it was")
    table.insert(textLines, "taken with the current instrument stettings.")
    table.insert(textLines, "")
    table.insert(textLines, "This script is licensed under the CC BY 4.0 - have fun!")
    
    for key,value in next, textLines do
        display.create(about_id, display.OBJ_TEXT, 12, 32*key, value, UNCERTAINTY_COLOR_HINTS_TEXT, display.FONT_MEDIUM)
    end

    local exit_id = display.create(about_id, display.OBJ_BUTTON, 350, 360, "Back")
    display.setevent(exit_id, display.EVENT_PRESS, "close_about()")
end

function close_about() -- Closes the about screen and goes back to swipe_id
    display.changescreen(display.SCREEN_HOME)
    display.delete(about_id)
    delay() -- Needed to allow change to swipe_id?
    display.changescreen(swipe_id)
    collectgarbage()
end

function getUnitSymbol()    
    local unitString = ""
    local func = dmm.measure.func
        if     func == dmm.FUNC_DC_VOLTAGE      then unitString = "V"
        elseif func == dmm.FUNC_DIODE       then unitString = "V"
        elseif func == dmm.FUNC_DC_CURRENT      then unitString = "A"
        elseif func == dmm.FUNC_RESISTANCE      then unitString = "\018"
        elseif func == dmm.FUNC_4W_RESISTANCE   then unitString = "\018"
        elseif func == dmm.FUNC_CAPACITANCE     then unitString = "F"
        elseif func == dmm.FUNC_AC_VOLTAGE      then unitString = "V"
        elseif func == dmm.FUNC_AC_CURRENT      then unitString = "A"
        elseif func == dmm.FUNC_ACV_FREQUENCY   then unitString = "Hz"
        elseif func == dmm.FUNC_ACV_PERIOD      then unitString = "s"
        else unitString = "X"
        end    
        return unitString
end

--[[ Take a float value,
  - convert it to max. 3 digits before the decimal point and
  - round it to roundingDigits digits after the decimal point
  - add a unit prefix (e.g. "k" for "kilo")
  - return the resulting string
  This does not add the unit itself!
--]]
function prettyPrintValue(value, roundingDigits)
    local unitPrefix = ""
    local absValue = math.abs(value)
    if absValue < 1e-9 then
        value = value * 1e12 -- pico-unit
        unitPrefix = "p"
    elseif absValue < 1e-6 then
        value = value * 1e9 -- nano-unit
        unitPrefix = "n"
    elseif absValue < 1e-3 then
        value = value * 1e6 -- micro-unit
        unitPrefix = "\020"
    elseif absValue < 1.0 then
        value = value * 1e3 -- milli-unit
        unitPrefix = "m"
    elseif absValue < 1e3 then
        value = value -- 1 ... 1000 --> no unit prefix
        unitPrefix = ""
    elseif absValue < 1e6 then
        value = value / 1e3 -- kilo-unit
        unitPrefix = "k"
    elseif absValue < 1e9 then
        value = value / 1e6 -- Mega-unit
        unitPrefix = "M"
    end
    value = round(value, roundingDigits)
    local prettyString = tostring(value) .. " " .. unitPrefix
    return prettyString
end

function setup() -- Calls other init functions and creates the timers
    
    -- create "defines" and global variables
    DisplayItems = {} -- Table that contains ids of the text object that display the values, filled in print_uncertainties()
      
    if(CalibrationInterval == nil) then
        CalibrationInterval = CALIBRATION_INTERVAL_1_YEAR -- set the default
    end
    
    --if screen_is_setup ~= 1 
    --then
         createMainScreen()
    --end --prevents multiple swipe screens being created
    
    -- Setup timers for ongoing stuff
	read_timer_id = display.create(swipe_id, display.OBJ_TIMER, 0.5, display.TIMER_FOREVER, "takeReading()")
	garbage_timer_id = display.create(swipe_id, display.OBJ_TIMER, 60, display.TIMER_FOREVER, "collectgarbage()")
    
    display.changescreen(display.SCREEN_HOME) -- Go to the newly created screen
    display.changescreen(swipe_id)
    
    uncertainty_numberOfReadingsInBuffer = defbuffer1.n -- create variable and make sure one reading is taken on script startup

    takeReading()
end

function check_valid(reading) -- Takes the most recent reading and verifies it's a reading I want
    if reading == 9.9e+37 then return false end -- Don't allow overflows  
    return true -- Reading is valid
end

function takeReading() -- take a reading and display the uncertainty
    if(TriggerReadingsFromApp == TRIGGER_READINGS_FROM_APP_ON) then -- 1 for "On", 2 for "Off"
        if((uncertainty_numberOfReadingsInBuffer == defbuffer1.n) or (defbuffer1.n == 0)) then -- no measurement was triggered from outside of this script?
            dmm.measure.read(defbuffer1)
            uncertainty_numberOfReadingsInBuffer = defbuffer1.n -- remember the amount of values in the buffer so we can detect changes next time
        end
    end
    update_uncertainties()
end

-- return the function which calculates the uncertainties for the readings in the
-- currently used measurement mode of the instrument
function getUncertaintyFunction()
    local func = dmm.measure.func
    if     func == dmm.FUNC_DC_VOLTAGE      then return getDcvUncertainty
    elseif func == dmm.FUNC_DC_CURRENT      then return getDciUncertainty
    elseif func == dmm.FUNC_RESISTANCE      then return getResistanceUncertainty
    elseif func == dmm.FUNC_4W_RESISTANCE   then return getResistanceUncertainty
    elseif func == dmm.FUNC_CAPACITANCE     then return getCapacitanceUncertainty
    elseif func == dmm.FUNC_DIODE           then return getDiodeUncertainty
    elseif func == dmm.FUNC_AC_VOLTAGE      then return getAcvUncertainty
    elseif func == dmm.FUNC_AC_CURRENT      then return getAciUncertainty
--    elseif func == dmm.FUNC_ACV_FREQUENCY   then return getAcvFrequencyUncertainty
--    elseif func == dmm.FUNC_ACV_PERIOD      then return getAcvPeriodUncertainty
--    elseif func == dmm.FUNC_DCV_RATIO       then bufferUnit = buffer.UNIT_RATIO
    else return getNoUncertainty
    end
 end


function getDcvUncertainty(reading, calInterval)
    local range = dmm.measure.range
    local baseUncertainty = getDcvBaseUncertainty(reading, range, calInterval)
    local additionalUncertainty = getDcvAdditionalUncertainty(reading, range, calInterval)
    return baseUncertainty + additionalUncertainty
end

function getDciUncertainty(reading, calInterval)
    local range = dmm.measure.range
    local baseUncertainty = getDciBaseUncertainty(reading, range, calInterval)
    local additionalUncertainty = getDciAdditionalUncertainty(reading, range, calInterval)
    return baseUncertainty + additionalUncertainty
end

function getResistanceUncertainty(reading, calInterval)
    local range = dmm.measure.range
    local baseUncertainty = getResistanceBaseUncertainty(reading, range, calInterval)
    local additionalUncertainty = getResistanceAdditionalUncertainty(reading, range, calInterval)
    return baseUncertainty + additionalUncertainty
end

function getDcvBaseUncertainty(reading, range, calInterval)    -- return measurement uncertainty in V
    local uncertOfReading = 0
    local uncertOfRange = 0
    if(calInterval == CALIBRATION_INTERVAL_24_H) then
        if range == 0.1 then 
            uncertOfReading = 0.0015/100
            uncertOfRange = 0.0030/100
        elseif range == 1 then
            uncertOfReading = 0.0015/100
            uncertOfRange = 0.0006/100
        elseif range == 10 then
            uncertOfReading = 0.0010/100
            uncertOfRange = 0.0004/100
        elseif range == 100 then
            uncertOfReading = 0.0015/100
            uncertOfRange = 0.0006/100
        elseif range == 1000 then
            uncertOfReading = 0.0020/100
            uncertOfRange = 0.0006/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_90_DAYS) then
        if range == 0.1 then 
            uncertOfReading = 0.0025/100
            uncertOfRange = 0.0035/100
        elseif range == 1 then
            uncertOfReading = 0.0020/100 
            uncertOfRange = 0.0006/100
        elseif range == 10 then
            uncertOfReading = 0.0020/100
            uncertOfRange = 0.0005/100
        elseif range == 100 then
            uncertOfReading = 0.0035/100
            uncertOfRange = 0.0006/100
        elseif range == 1000 then
            uncertOfReading = 0.0035/100
            uncertOfRange = 0.0006/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_1_YEAR) then
        if range == 0.1 then 
            uncertOfReading = 0.0030/100
            uncertOfRange = 0.0035/100
        elseif range == 1 then
            uncertOfReading = 0.0025/100 
            uncertOfRange = 0.0006/100
        elseif range == 10 then
            uncertOfReading = 0.0025/100
            uncertOfRange = 0.0005/100
        elseif range == 100 then
            uncertOfReading = 0.0040/100
            uncertOfRange = 0.0006/100
        elseif range == 1000 then
            uncertOfReading = 0.0040/100
            uncertOfRange = 0.0006/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_2_YEARS) then
        if range == 0.1 then 
            uncertOfReading = 0.0035/100
            uncertOfRange = 0.0035/100
        elseif range == 1 then
            uncertOfReading = 0.0030/100 
            uncertOfRange = 0.0006/100
        elseif range == 10 then
            uncertOfReading = 0.0030/100
            uncertOfRange = 0.0005/100
        elseif range == 100 then
            uncertOfReading = 0.0050/100
            uncertOfRange = 0.0006/100
        elseif range == 1000 then
            uncertOfReading = 0.0050/100
            uncertOfRange = 0.0006/100
        end
    end
    return reading*uncertOfReading + range * uncertOfRange
end

function getDcvAdditionalUncertainty(reading, range, calInterval)
    local noiseOfRange = 0
    local noiseFixedValue = 0
    local noAutoZeroUncertOfRange = 0
    local noAutoZeroUncertFixedValue = 0
    local nplc = dmm.measure.nplc -- numeric
    local lineSyncState = dmm.measure.linesync -- dmm.OFF or dmm.ON
    local autoZeroState = dmm.measure.autozero.enable -- dmm.OFF or dmm.ON

    -- handle MEASUREMENT NOISE CHARACTERISTICS
    -- Attention: The spcification lists RMS noise, not peak noise. We do the conversion at the end...
    if(nplc < 0.01) then -- spec sheet specifies 0.0005 PLC, I assume the values are valid from 0.0005 - 0.01 PLC
        noiseOfRange = 0.00500/100
        noiseFixedValue = 40e-6 -- 40 uV
    elseif (nplc < 0.1) then -- spec sheet specifies 0.01 PLC, I assume the values are valid from 0.01 - 0.1 PLC
        noiseOfRange = 0.00030/100
        noiseFixedValue = 6e-6 -- 6 uV
    elseif (nplc < 1.0) then -- spec sheet specifies 0.1 PLC, I assume the values are valid from 0.1 - 1 PLC
        noiseOfRange = 0.00015/100
        if(lineSyncState == dmm.OFF) then
            noiseFixedValue = 4e-6 -- 4 uV

        else -- line sync on
            noiseFixedValue = 1e-6 -- 1 uV
        end
    -- no additional noise penalty for NPLC >= 1
    end

    -- convert RMS noise spec to peak noise spec
    -- this is an approximation though, as we don't know the noise spectrum characteristics
    noiseOfRange = noiseOfRange * 3
    noiseFixedValue = noiseFixedValue * 3

    -- handle "autozero off" penalty
    if(autoZeroState == dmm.OFF) then
        noAutoZeroUncertOfRange = 0.0010/100 -- assuming worst specified case: within ±5 °C and ≤ 60 minutes since last autozero
        noAutoZeroUncertFixedValue = 10.0e-6 -- 10 uV        
    end
    return range * (noiseOfRange + noAutoZeroUncertOfRange) + noiseFixedValue + noAutoZeroUncertFixedValue
end

function getDciBaseUncertainty(reading, range, calInterval) -- return measurement uncertainty in A
    local uncertOfReading = 0
    local uncertOfRange = 0
    if(calInterval == CALIBRATION_INTERVAL_24_H) then
        if range == 0.00001 then -- 10 µA
            return reading * 0.007/100 + range * 0.002/100
        elseif range == 0.0001 then -- 100 µA
            return reading * 0.010/100 + range * 0.002/100
        elseif range == 0.001 then -- 1 mA
            return reading * 0.007/100 + range * 0.006/100
        elseif range == 0.01 then -- 10 mA
            return reading * 0.006/100 + range * 0.003/100
        elseif range == 0.1 then
            return reading * 0.010/100 + range * 0.003/100
        elseif range == 1 then
            return reading * 0.020/100 + range * 0.004/100
        elseif range == 3 then
            return reading * 0.030/100 + range * 0.004/100
        elseif range == 10 then
            return reading * 0.140/100 + range * 0.025/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_90_DAYS) then
        if range == 0.00001 then -- 10 µA
            return reading * 0.035/100 + range * 0.005/100
        elseif range == 0.0001 then -- 100 µA
            return reading * 0.035/100 + range * 0.005/100
        elseif range == 0.001 then -- 1 mA
            return reading * 0.035/100 + range * 0.005/100
        elseif range == 0.01 then -- 10 mA
            return reading * 0.018/100 + range * 0.005/100
        elseif range == 0.1 then
            return reading * 0.015/100 + range * 0.005/100
        elseif range == 1 then
            return reading * 0.030/100 + range * 0.005/100
        elseif range == 3 then
            return reading * 0.040/100 + range * 0.004/100
        elseif range == 10 then
            return reading * 0.190/100 + range * 0.025/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_1_YEAR) then
        if range == 0.00001 then -- 10 µA
            return reading * 0.045/100 + range * 0.005/100
        elseif range == 0.0001 then -- 100 µA
            return reading * 0.045/100 + range * 0.005/100
        elseif range == 0.001 then -- 1 mA
            return reading * 0.045/100 + range * 0.005/100
        elseif range == 0.01 then -- 10 mA
            return reading * 0.020/100 + range * 0.005/100
        elseif range == 0.1 then
            return reading * 0.020/100 + range * 0.005/100
        elseif range == 1 then
            return reading * 0.040/100 + range * 0.005/100
        elseif range == 3 then
            return reading * 0.050/100 + range * 0.004/100
        elseif range == 10 then
            return reading * 0.220/100 + range * 0.025/100
        end
    elseif (calInterval == CALIBRATION_INTERVAL_2_YEARS) then
        if range == 0.00001 then -- 10 µA
            return reading * 0.055/100 + range * 0.005/100
        elseif range == 0.0001 then -- 100 µA
            return reading * 0.055/100 + range * 0.005/100
        elseif range == 0.001 then -- 1 mA
            return reading * 0.055/100 + range * 0.005/100
        elseif range == 0.01 then -- 10 mA
            return reading * 0.025/100 + range * 0.005/100
        elseif range == 0.1 then
            return reading * 0.025/100 + range * 0.005/100
        elseif range == 1 then
            return reading * 0.050/100 + range * 0.005/100
        elseif range == 3 then
            return reading * 0.060/100 + range * 0.004/100
        elseif range == 10 then
            return reading * 0.250/100 + range * 0.025/100
        end
    end
end

function getDciAdditionalUncertainty(reading, range, calInterval)
    local noiseOfRange = 0
    local noiseFixedValue = 0
    local noAutoZeroUncertOfRange = 0
    local noAutoZeroUncertFixedValue = 0
    local nplc = dmm.measure.nplc -- numeric
    local lineSyncState = dmm.measure.linesync -- dmm.OFF or dmm.ON
    local autoZeroState = dmm.measure.autozero.enable -- dmm.OFF or dmm.ON

    -- handle MEASUREMENT NOISE CHARACTERISTICS
    if(nplc < 0.01) then -- spec sheet specifies 0.0005 PLC, I assume the values are valid from 0.0005 - 0.01 PLC
        noiseOfRange = 0.0200/100
        noiseFixedValue = 5e-9 -- 5 nA
    elseif (nplc < 0.1) then -- spec sheet specifies 0.01 PLC, I assume the values are valid from 0.01 - 0.1 PLC
        noiseOfRange = 0.0030/100
        noiseFixedValue = 5e-9
    elseif (nplc < 1.0) then -- spec sheet specifies 0.1 PLC, I assume the values are valid from 0.1 - 1 PLC        
        if(lineSyncState == dmm.OFF) then
            noiseOfRange = 0.0015/100
            noiseFixedValue = 5e-9
        else -- line sync on
            noiseOfRange = 0.0009/100
            noiseFixedValue = 10e-12 -- 10 pA
        end
    -- no additional noise penalty for NPLC >= 1
    end

    -- convert RMS noise spec to peak noise spec
    -- this is an approximation though, as we don't know the noise spectrum characteristics
    noiseOfRange = noiseOfRange * 3
    noiseFixedValue = noiseFixedValue * 3

    -- handle "autozero off" penalty
    if(autoZeroState == dmm.OFF) then
        noAutoZeroUncertOfRange = 0.015/100 -- assuming worst specified case: within ±5 °C and ≤ 60 minutes since last autozero
        noAutoZeroUncertFixedValue = 0.0 -- none specified
    end
    return range * (noiseOfRange + noAutoZeroUncertOfRange) + noiseFixedValue + noAutoZeroUncertFixedValue    
end

function getResistanceBaseUncertainty(reading, range, calInterval) -- return measurement uncertainty in A
    if(calInterval == CALIBRATION_INTERVAL_24_H) then
        if range == 1 then
            return reading * 0.0080/100 + range * 0.0200/100
        elseif range == 10 then
            return reading * 0.0020/100 + range * 0.0020/100
        elseif range == 100 then
            return reading * 0.0020/100 + range * 0.0020/100
        elseif range == 1000 then
            return reading * 0.0020/100 + range * 0.0006/100
        elseif range == 10000 then   -- 10k
            return reading * 0.0020/100 + range * 0.0006/100
        elseif range == 100000 then  -- 100k
            return reading * 0.0020/100 + range * 0.0006/100
        elseif range == 1000000 then -- 1 Meg
            return reading * 0.0020/100 + range * 0.0006/100
        elseif range == 10000000 then -- 10 Meg
            return reading * 0.0150/100 + range * 0.0006/100
        elseif range == 100000000 then -- 100 Meg
            return reading * 0.0800/100 + range * 0.0030/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_90_DAYS) then
        if range == 1 then
            return reading * 0.0080/100 + range * 0.0200/100
        elseif range == 10 then
            return reading * 0.0080/100 + range * 0.0020/100
        elseif range == 100 then
            return reading * 0.0075/100 + range * 0.0020/100
        elseif range == 1000 then
            return reading * 0.0065/100 + range * 0.0006/100
        elseif range == 10000 then   -- 10k
            return reading * 0.0065/100 + range * 0.0006/100
        elseif range == 100000 then  -- 100k
            return reading * 0.0070/100 + range * 0.0010/100
        elseif range == 1000000 then -- 1 Meg
            return reading * 0.0075/100 + range * 0.0006/100
        elseif range == 10000000 then -- 10 Meg
            return reading * 0.0200/100 + range * 0.0010/100
        elseif range == 100000000 then -- 100 Meg
            return reading * 0.2000/100 + range * 0.0030/100
        end
    elseif(calInterval == CALIBRATION_INTERVAL_1_YEAR) then
        if range == 1 then
            return reading * 0.0085/100 + range * 0.0200/100
        elseif range == 10 then
            return reading * 0.0085/100 + range * 0.0020/100
        elseif range == 100 then
            return reading * 0.0085/100 + range * 0.0020/100
        elseif range == 1000 then
            return reading * 0.0075/100 + range * 0.0006/100
        elseif range == 10000 then   --10k
            return reading * 0.0075/100 + range * 0.0006/100
        elseif range == 100000 then  -- 100k
            return reading * 0.0075/100 + range * 0.0010/100
        elseif range == 1000000 then -- 1 Meg
            return reading * 0.0100/100 + range * 0.0006/100
        elseif range == 10000000 then -- 10 Meg
            return reading * 0.0400/100 + range * 0.0010/100
        elseif range == 100000000 then -- 100 Meg
            return reading * 0.2000/100 + range * 0.0030/100
        end
    elseif (calInterval == CALIBRATION_INTERVAL_2_YEARS) then
        if range == 1 then
            return reading * 0.0100/100 + range * 0.0200/100
        elseif range == 10 then
            return reading * 0.0100/100 + range * 0.0020/100
        elseif range == 100 then
            return reading * 0.0100/100 + range * 0.0020/100
        elseif range == 1000 then
            return reading * 0.0090/100 + range * 0.0006/100
        elseif range == 10000 then   --10k
            return reading * 0.0090/100 + range * 0.0006/100
        elseif range == 100000 then  -- 100k
            return reading * 0.0100/100 + range * 0.0010/100
        elseif range == 1000000 then -- 1 Meg
            return reading * 0.0120/100 + range * 0.0006/100
        elseif range == 10000000 then -- 10 Meg
            return reading * 0.0450/100 + range * 0.0010/100
        elseif range == 100000000 then -- 100 Meg
            return reading * 0.250/100 + range * 0.0030/100
        end
    end
end

function getResistanceAdditionalUncertainty(reading, range, calInterval)
    local noiseOfRange = 0
    local noiseFixedValue = 0
    local noAutoZeroUncertOfRange = 0
    local noAutoZeroUncertFixedValue = 0
    local TwoWireModeUncertFixedValue = 0
    local nplc = dmm.measure.nplc -- numeric
    local lineSyncState = dmm.measure.linesync -- dmm.OFF or dmm.ON
    local autoZeroState = dmm.measure.autozero.enable -- dmm.OFF or dmm.ON   
    local kelvinConnectionsState = dmm.OFF
    
    if (dmm.measure.func == dmm.FUNC_4W_RESISTANCE) then
        kelvinConnectionsState = dmm.ON
    end

    -- handle MEASUREMENT NOISE CHARACTERISTICS
    if(range <= 1000000) then -- RESISTANCE MEASUREMENT NOISE CHARACTERISTICS apply for 1 Ω through 1 MΩ ranges only
        if(kelvinConnectionsState == dmm.OFF) then -- we are in 2-wire resistance mode  
            if(nplc < 0.01) then -- spec sheet specifies 0.0005 PLC, I assume the values are valid from 0.0005 - 0.01 PLC
                noiseOfRange = 0.00650/100
                noiseFixedValue = 3.5E-3 -- 3.5 mOhm
            elseif (nplc < 0.1) then -- spec sheet specifies 0.01 PLC, I assume the values are valid from 0.01 - 0.1 PLC
                noiseOfRange = 0.00070/100
                noiseFixedValue = 0.5E-3 -- 0.5 mOhm
            elseif (nplc < 1.0) then -- spec sheet specifies 0.1 PLC, I assume the values are valid from 0.1 - 1 PLC        
                if(lineSyncState == dmm.OFF) then
                    noiseOfRange = 0.0005/100
                    noiseFixedValue = 0.35E-3 -- 0.35 mOhm
                else -- line sync on
                    noiseOfRange = 0.00015/100
                    noiseFixedValue = 0.1E-3 -- 0.1 mOhm
                end
            -- no additional noise penalty for NPLC >= 1            
            end
        elseif(kelvinConnectionsState == dmm.ON) then -- we are in 4-wire resistance mode
            if (dmm.OCOMP_OFF == dmm.measure.offsetcompensation.enable) then -- 4-wire mode, but offset compensation off?    
                if(nplc < 0.01) then -- spec sheet specifies 0.0005 PLC, I assume the values are valid from 0.0005 - 0.01 PLC
                    noiseOfRange = 0.01000/100
                    noiseFixedValue = 7.0E-3
                elseif (nplc < 0.1) then -- spec sheet specifies 0.01 PLC, I assume the values are valid from 0.01 - 0.1 PLC
                    noiseOfRange = 0.00260/100
                    noiseFixedValue = 2.5E-3 -- 0.5 mOhm
                elseif (nplc < 1.0) then -- spec sheet specifies 0.1 PLC, I assume the values are valid from 0.1 - 1 PLC        
                    if(lineSyncState == dmm.OFF) then
                        noiseOfRange = 0.00180/100
                        noiseFixedValue = 2.0E-3
                    else -- line sync on
                        noiseOfRange = 0.00020/100
                        noiseFixedValue = 0.2E-3
                    end
                    -- no additional noise penalty for NPLC >= 1
                end
            else -- 4-wire mode, offset compensation on
                if(nplc < 0.01) then -- spec sheet specifies 0.0005 PLC, I assume the values are valid from 0.0005 - 0.01 PLC
                    noiseOfRange = 0.01500/100
                    noiseFixedValue = 10E-3
                elseif (nplc < 0.1) then -- spec sheet specifies 0.01 PLC, I assume the values are valid from 0.01 - 0.1 PLC
                    noiseOfRange = 0.00500/100
                    noiseFixedValue = 4.0E-3
                elseif (nplc < 1.0) then -- spec sheet specifies 0.1 PLC, I assume the values are valid from 0.1 - 1 PLC        
                    if(lineSyncState == dmm.OFF) then
                        noiseOfRange = 0.00350/100
                        noiseFixedValue = 3.5E-3
                    else -- line sync on
                        noiseOfRange = 0.00030/100
                        noiseFixedValue = 0.25E-3 -- 0.1 mOhm
                    end
                -- no additional noise penalty for NPLC >= 1
                end  
            end           
        end

        if(range ==100) then -- "For 100 Ω range, multiply the listed values by five."
            noiseOfRange = noiseOfRange * 5
            noiseFixedValue = noiseFixedValue * 5
        end
    end

    -- convert RMS noise spec to peak noise spec
    -- this is an approximation though, as we don't know the noise spectrum characteristics
    noiseOfRange = noiseOfRange * 3
    noiseFixedValue = noiseFixedValue * 3

    -- handle "autozero off" penalty
    if(autoZeroState == dmm.OFF) then -- assuming worst specified case: within ±5 °C and ≤ 60 minutes since last autozero
        noAutoZeroUncertOfRange = 0.0020/100 
        noAutoZeroUncertFixedValue = 10e-3 -- 10 mOhm
    end

    if kelvinConnectionsState == dmm.OFF then -- we are in 2-wire resistance mode?
        TwoWireModeUncertFixedValue = 0.1 -- 100 mOhm penalty
    end

    return range * (noiseOfRange + noAutoZeroUncertOfRange) + noiseFixedValue + noAutoZeroUncertFixedValue + TwoWireModeUncertFixedValue
end

function getCapacitanceUncertainty(reading, calInterval)
    -- note: There is only a 2-year accuracy spec for capacitance measurement!
    local range = dmm.measure.range
    if range == 1e-9 then -- 1 nF
        return reading * 0.80/100 + range * 0.5/100
    else
        return reading * 0.40/100 + range * 0.1/100 -- 10 nF to 100 uF ranges all have the same spec!    
    end
end

function getDiodeUncertainty(reading, calInterval)
    -- note: There is only a 2-year accuracy spec for diode measurement!
    local biasLevel = dmm.measure.bias.level
    if biasLevel == 1e-5 then -- 10 uA
        return reading * 0.0045/100 + 60e-6
    elseif biasLevel == 0.0001 then -- 100 uA
        return reading * 0.0045/100 + 80e-6
    elseif biasLevel == 0.001 then -- 1 mA
        return reading * 0.0045/100 + 170e-6
    else -- 10 mA
        return reading * 0.0045/100 + 1.1e-3
    end
end

function getAcvUncertainty(reading, calInterval)
    -- the relative specification of the calibration cycle does not depend on the range,
    -- but only on the calibration cycle!
    local range = dmm.measure.range
    if CalibrationInterval == CALIBRATION_INTERVAL_24_H then
        if AcvFrequency == ACV_FREQUENCY_3HzTo5Hz then
            return reading * 1.00/100 + range * 0.02/100
        elseif AcvFrequency == ACV_FREQUENCY_5HzTo10Hz then
            return reading * 0.35/100 + range * 0.02/100
        elseif AcvFrequency == ACV_FREQUENCY_10HzTo20kHz then
            return reading * 0.04/100 + range * 0.02/100
        elseif AcvFrequency == ACV_FREQUENCY_20kHzTo50kHz then
            return reading * 0.10/100 + range * 0.04/100
        elseif AcvFrequency == ACV_FREQUENCY_50kHzTo100kHz then
            return reading * 0.55/100 + range * 0.08/100
        elseif AcvFrequency == ACV_FREQUENCY_100kHzTo300kHz then
            return reading * 4.00/100 + range * 0.5/100
        else return 0 -- illegal frequency
        end
    elseif CalibrationInterval == CALIBRATION_INTERVAL_90_DAYS then
        if AcvFrequency == ACV_FREQUENCY_3HzTo5Hz then
            return reading * 1.00/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_5HzTo10Hz then
            return reading * 0.35/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_10HzTo20kHz then
            return reading * 0.05/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_20kHzTo50kHz then
            return reading * 0.11/100 + range * 0.05/100
        elseif AcvFrequency == ACV_FREQUENCY_50kHzTo100kHz then
            return reading * 0.60/100 + range * 0.08/100
        elseif AcvFrequency == ACV_FREQUENCY_100kHzTo300kHz then
            return reading * 4.00/100 + range * 0.5/100
        else return 0 -- illegal frequency
        end
    elseif CalibrationInterval == CALIBRATION_INTERVAL_1_YEAR then
        if AcvFrequency == ACV_FREQUENCY_3HzTo5Hz then
            return reading * 1.00/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_5HzTo10Hz then
            return reading * 0.35/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_10HzTo20kHz then
            return reading * 0.06/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_20kHzTo50kHz then
            return reading * 0.12/100 + range * 0.05/100
        elseif AcvFrequency == ACV_FREQUENCY_50kHzTo100kHz then
            return reading * 0.60/100 + range * 0.08/100
        elseif AcvFrequency == ACV_FREQUENCY_100kHzTo300kHz then
            return reading * 4.00/100 + range * 0.5/100
        else return 0 -- illegal frequency
        end
    elseif CalibrationInterval == CALIBRATION_INTERVAL_2_YEARS then
        if AcvFrequency == ACV_FREQUENCY_3HzTo5Hz then
            return reading * 1.00/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_5HzTo10Hz then
            return reading * 0.35/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_10HzTo20kHz then
            return reading * 0.07/100 + range * 0.03/100
        elseif AcvFrequency == ACV_FREQUENCY_20kHzTo50kHz then
            return reading * 0.13/100 + range * 0.05/100
        elseif AcvFrequency == ACV_FREQUENCY_50kHzTo100kHz then
            return reading * 0.60/100 + range * 0.08/100
        elseif AcvFrequency == ACV_FREQUENCY_100kHzTo300kHz then
            return reading * 4.00/100 + range * 0.5/100
        else return 0 -- illegal frequency
        end
    else
        return 0 -- illegal cal interval
    end
end

function getAciUncertainty(reading, calInterval) -- AC current
-- TODO
    local range = dmm.measure.range
    if(range == 100E-6) then -- 100 uA              
        if (AciFrequency == ACI_FREQUENCY_3HzTo5Hz) or (AciFrequency == ACI_FREQUENCY_5HzTo1kHz) then
            return reading * 0.10/100 + range * 0.07/100
        elseif (AciFrequency == ACI_FREQUENCY_1kHzTo5kHz) or (AciFrequency == ACI_FREQUENCY_5kHzTo10kHz) then
            return reading * 0.15/100 + range * 0.07/100
        end
    elseif (range == 1E-3) or (range == 10E-3) or (range == 100E-3) then -- 1 mA - 100 mA ranges   
        return reading * 0.10/100 + range * 0.04/100 -- independent of frequency        
    elseif (range == 1.0) then -- 1 A range
        if (AciFrequency == ACI_FREQUENCY_3HzTo5Hz)  then
            return reading * 0.30/100 + range * 0.04/100 -- footnote 24
        elseif (AciFrequency == ACI_FREQUENCY_5HzTo1kHz) then
            return reading * 0.10/100 + range * 0.04/100
        else -- >5 kHz
            return reading * 0.15/100 + range * 0.06/100
        end
    elseif (range == 3.0) then -- 3 A range
        if (AciFrequency == ACI_FREQUENCY_3HzTo5Hz)  then
            return reading * 0.35/100 + range * 0.06/100 -- footnote 24
        else 
            return reading * 0.15/100 + range * 0.06/100 
        end
    elseif (range == 10.0) then -- 10 A range
        if (AciFrequency == ACI_FREQUENCY_3HzTo5Hz)  then
            return reading * 0.6/100 + range * 0.06/100 -- footnote 24
        elseif (AciFrequency == ACI_FREQUENCY_5HzTo1kHz) then
            return reading * 0.4/100 + range * 0.06/100 
        elseif (AciFrequency == ACI_FREQUENCY_1kHzTo5kHz) or (AciFrequency == ACI_FREQUENCY_5kHzTo10kHz) then
            return reading * 1.0/100 + range * 0.07/100
        end
    end
end

function getNoUncertainty(reading, calInterval)
    return 0
end

function getUncertainty() --get the measurement uncertainty of the last measured value in defbuffer1, assumig it was taken with the current instrument stettings
    if(defbuffer1.n ~= 0) then -- make sure there is a reading in the buffer    
        local reading = defbuffer1[defbuffer1.endindex] -- the last reading that was taken by the meter
        
        if (check_valid(reading) == false) then
            return nil
        end    
        local uncertaintyFunction = getUncertaintyFunction();
        return uncertaintyFunction(math.abs(reading), CalibrationInterval)
    end
end

function update_uncertainties() -- Updates the number display
    if(defbuffer1.n ~= 0) then -- make sure there is a reading in the buffer
        local reading = defbuffer1[defbuffer1.endindex] -- the last reading that was taken by the meter   
        local uncertainty = getUncertainty()
        if (uncertainty==nil) then 
            display.settext(DisplayItems[5], "---")
            display.settext(DisplayItems[6], "---")
            display.settext(DisplayItems[7], "---")
            display.settext(DisplayItems[8], "---")
        else
            display.settext(DisplayItems[5], prettyPrintValue(uncertainty, ABS_UNCERTAINTY_ROUNDING_DIGITS) .. getUnitSymbol()) -- absolute uncertainty
            if(reading ~= 0.0) then
                display.settext(DisplayItems[6], tostring(round(uncertainty/math.abs(reading)*1e6, REL_UNCERTAINTY_ROUNDING_DIGITS)) .. " " .. "ppm") -- relative uncertainty
            else
                display.settext(DisplayItems[6], "--- " .. "ppm") -- relative uncertainty
            end
            display.settext(DisplayItems[7], prettyPrintValue(reading - uncertainty, ERROR_LIMITS_ROUNDING_DIGITS) .. getUnitSymbol())
            display.settext(DisplayItems[8], prettyPrintValue(reading + uncertainty, ERROR_LIMITS_ROUNDING_DIGITS) .. getUnitSymbol())
        end
    end
end

function round(vaule, digits)
    digits = math.pow(10, digits or 0)
    vaule = vaule * digits
    if vaule >= 0 then vaule = math.floor(vaule + 0.5) else vaule = math.ceil(vaule - 0.5) end
    return vaule / digits
end


function main() -- Does nothing in this App, here for posterity
end

--------------------------------- Script starts here ---------------------------------------
-- define values to use for calibrationInterval (like an enum)
CALIBRATION_INTERVAL_24_H    = 1
CALIBRATION_INTERVAL_90_DAYS = 2
CALIBRATION_INTERVAL_1_YEAR  = 3
CALIBRATION_INTERVAL_2_YEARS = 4

TRIGGER_READINGS_FROM_APP_ON = 1
TRIGGER_READINGS_FROM_APP_OFF = 2

ACV_FREQUENCY_3HzTo5Hz            = 1
ACV_FREQUENCY_5HzTo10Hz           = 2
ACV_FREQUENCY_10HzTo20kHz         = 3
ACV_FREQUENCY_20kHzTo50kHz        = 4
ACV_FREQUENCY_50kHzTo100kHz       = 5
ACV_FREQUENCY_100kHzTo300kHz      = 6

ACI_FREQUENCY_3HzTo5Hz            = 1
ACI_FREQUENCY_5HzTo1kHz           = 2
ACI_FREQUENCY_1kHzTo5kHz          = 3
ACI_FREQUENCY_5kHzTo10kHz         = 4

-- define display settings
ABS_UNCERTAINTY_ROUNDING_DIGITS = 2
REL_UNCERTAINTY_ROUNDING_DIGITS = 2
ERROR_LIMITS_ROUNDING_DIGITS = 4

-- define display colors - try to match the original look of the UI!
UNCERTAINTY_COLOR_VALUE_LABEL = display.COLOR_VALUE_LABEL --0x047EA6
UNCERTAINTY_COLOR_VALUE_VALUE = display.COLOR_VALUE_VALUE --0xE0E0E0
UNCERTAINTY_COLOR_HINTS_TEXT = display.COLOR_VALUE_VALUE

-- Variables for global settings - set to defaults
TriggerReadingsFromApp = TRIGGER_READINGS_FROM_APP_ON --Trigger measuremnts regularly from the script. Can be switched off for remote operation
AcvFrequency = ACV_FREQUENCY_10HzTo20kHz
AciFrequency = ACI_FREQUENCY_5HzTo1kHz

-- Call opening functions and main()
--reset()
collectgarbage() -- Built-in function
setup()
main()


endscript

loadimage uncertainty_icon Uncertainty
iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAIAAAC1nk4lAAADkklEQVRo3u2ZQUjbYBTH3xd0l9KLQsUNhOlgl4FUGlMYuwzxICNeI14i8yBM5qFHD8XDjh4qFXZosRex7GbZaYxdvDRN
tyI7CW4yQcSC7iC7TNbs8OTrRxptkub7jJBHKWkIyS//vrzv/16IZVlw30KCexgRdAQdQYcg+twfatRrxr4JAI3Pn+jO5NS0Mi4rqcnQKb1R3CSEpGVlZXGZJcYbSMsKIWSjuCkMmty+
uGwUN1cWlwEgV8jbWEvliq6pKDbdUzUNEapbN4euqbqmVk0Df3YeXDUNvBldU3OFPN5DrpC3vMftJLa4VtoaJeyd1D4YaVnJxuLZ3/1npB93DvefnV4N0WNmvj+k2yfrxzP/nuN2qVzJ
FfKliWJXvb4++9VO0wcXrb8D1z+eXtyYGD+tdnrYoKUjaD0GAICDATfQ1zkz0UjMDwJAc/s8+S3JD9rhQZSOIBuL+8g0CpqYH2xMNMRVD+kIACCbuPR3ukeZkeb2OXKfrB+LgF5rxrOx
uD+ZaSTmB5EbvwXVad8yU7Exs7mK3Y4XTyT8BHI2ROe4uFijZK0Zd1D6YAAAsIB0rR5sUI0fZUb4Vo9s4vLL8J9gVeGRIbxcHi0jd2aYhqyrUOW0veS9PI3R5A5ttF0e2mVlXDb2zbev
3zgcSoinecPC3Cx6QMez9XJyyWY4bR6/xyiVK8q4zDE9qA9OTk0H6Oi52GubP0YDzdpof5a3ahqevLWnk0uOqixlVt+vv3NsE902lPsmALjJ5mA6F5QZOxHLV6DMnf9VUAGOl2S5vV6b
N7EzdCd3rpB3CYHEnhI0MGjKjbhd0WmHi1YRN/iJ3aWk4wKxlFnFZ4uWcBwbYOCMQdfU5NT0yuIyQu8dtpCbR8nrvg4Z9RpWEhwmscWBTj+WMqsIh3MS3txuF09c5G2LpeNMTAQ3j5zD
qQ3bB/mb4Hh+EHsJrCEUOnBuXrUJi4mN2/dq5a169BILc7M/6h/ZPXuHLV1Tt3Z2BT2IPsKo19KyYuvtA+Hm+CZASU3aBsSYMKVyhRDi3nsJVfqmJOm9FHKHxiTBIsjSI7e/q3N/UYRJ
grhjqVdsnlCbEDqlad+KYnfqnSvkvfYKgqDZJLGh7x22vDIIeo+opCZ1TWU1ZlPFayXpA1GxtbNLCBlLOZSRUBim2z0JvjTrhUEoNPUkbPhocAQ9iI5dBfZEPtaXO4AO73w6go6gI+gI
OoIOJv4D3PJ82t17xxcAAAAASUVORK5CYII=
endimage

Uncertainty.save()
